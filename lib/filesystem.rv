// lib/filesystem.rv - File System Library

// File information structure
struct FileInfo {
    name: String,
    size: int,
    is_directory: bool,
    is_file: bool
}

// Directory listing
export fun list_directory(path: String) -> String[] {
    // This would normally list directory contents
    // For now, return a placeholder
    let files: String[] = ["file1.txt", "file2.txt", "subdir"];
    return files;
}

export fun list_files(path: String) -> String[] {
    let all_items: String[] = list_directory(path);
    let files: String[] = [];
    
    let i: int = 0;
    while (i < len(all_items)) {
        // Simple heuristic: files don't end with "/"
        if (!all_items[i].ends_with("/")) {
            files.push(all_items[i]);
        }
        i = i + 1;
    }
    
    return files;
}

export fun list_directories(path: String) -> String[] {
    let all_items: String[] = list_directory(path);
    let dirs: String[] = [];
    
    let i: int = 0;
    while (i < len(all_items)) {
        // Simple heuristic: directories end with "/"
        if (all_items[i].ends_with("/")) {
            dirs.push(all_items[i]);
        }
        i = i + 1;
    }
    
    return dirs;
}

// Path manipulation
export fun join_path(parts: String[]) -> String {
    if (len(parts) == 0) {
        return "";
    }
    
    let result: String = parts[0];
    let i: int = 1;
    while (i < len(parts)) {
        if (!result.ends_with("/") && !parts[i].starts_with("/")) {
            result = result + "/";
        }
        result = result + parts[i];
        i = i + 1;
    }
    
    return result;
}

export fun split_path(path: String) -> String[] {
    return path.split("/");
}

export fun dirname(path: String) -> String {
    let parts: String[] = split_path(path);
    if (len(parts) <= 1) {
        return ".";
    }
    
    let result: String[] = [];
    let i: int = 0;
    while (i < len(parts) - 1) {
        result.push(parts[i]);
        i = i + 1;
    }
    
    return join_path(result);
}

export fun basename(path: String) -> String {
    let parts: String[] = split_path(path);
    if (len(parts) == 0) {
        return "";
    }
    return parts[len(parts) - 1];
}

export fun extension(path: String) -> String {
    let filename: String = basename(path);
    let last_dot: int = filename.last_index_of(".");
    
    if (last_dot == -1) {
        return "";
    }
    
    return filename.slice(last_dot + 1, len(filename));
}

export fun remove_extension(path: String) -> String {
    let filename: String = basename(path);
    let last_dot: int = filename.last_index_of(".");
    
    if (last_dot == -1) {
        return path;
    }
    
    let dir: String = dirname(path);
    let name_without_ext: String = filename.slice(0, last_dot);
    
    if (dir == ".") {
        return name_without_ext;
    } else {
        return join_path([dir, name_without_ext]);
    }
}

// File operations
export fun copy_file(source: String, destination: String) -> bool {
    if (!file_exists(source)) {
        return false;
    }
    
    let content: String = read_file(source);
    if (len(content) == 0) {
        return false;
    }
    
    write_file(destination, content);
    return true;
}

export fun move_file(source: String, destination: String) -> bool {
    if (!copy_file(source, destination)) {
        return false;
    }
    
    // In a real implementation, we would delete the source file here
    // For now, we'll just return true
    return true;
}

export fun create_directory(path: String) -> bool {
    // This would normally create a directory
    // For now, return true as a placeholder
    return true;
}

export fun remove_directory(path: String) -> bool {
    // This would normally remove a directory
    // For now, return true as a placeholder
    return true;
}

export fun remove_file(path: String) -> bool {
    // This would normally remove a file
    // For now, return true as a placeholder
    return true;
}

// File information
export fun get_file_info(path: String) -> FileInfo {
    let info: FileInfo = FileInfo { name: basename(path), size: 0, is_directory: false, is_file: false };
    
    if (file_exists(path)) {
        info.is_file = true;
        // In a real implementation, we would get the actual file size
        info.size = 1024; // Placeholder size
    }
    
    // Simple heuristic: directories end with "/"
    if (path.ends_with("/")) {
        info.is_directory = true;
        info.is_file = false;
    }
    
    return info;
}

export fun get_file_size(path: String) -> int {
    let info: FileInfo = get_file_info(path);
    return info.size;
}

export fun is_directory(path: String) -> bool {
    let info: FileInfo = get_file_info(path);
    return info.is_directory;
}

export fun is_file(path: String) -> bool {
    let info: FileInfo = get_file_info(path);
    return info.is_file;
}

// File reading utilities
export fun read_lines(path: String) -> String[] {
    let content: String = read_file(path);
    if (len(content) == 0) {
        return [];
    }
    
    return content.split("\n");
}

export fun write_lines(path: String, lines: String[]) -> bool {
    let content: String = lines.join("\n");
    write_file(path, content);
    return true;
}

export fun append_line(path: String, line: String) -> bool {
    let content: String = read_file(path);
    let new_content: String = content + "\n" + line;
    write_file(path, new_content);
    return true;
}

// File searching
export fun find_files(directory: String, pattern: String) -> String[] {
    let all_files: String[] = list_files(directory);
    let matching_files: String[] = [];
    
    let i: int = 0;
    while (i < len(all_files)) {
        if (all_files[i].contains(pattern)) {
            matching_files.push(all_files[i]);
        }
        i = i + 1;
    }
    
    return matching_files;
}

export fun find_files_by_extension(directory: String, ext: String) -> String[] {
    let all_files: String[] = list_files(directory);
    let matching_files: String[] = [];
    
    let i: int = 0;
    while (i < len(all_files)) {
        if (extension(all_files[i]) == ext) {
            matching_files.push(all_files[i]);
        }
        i = i + 1;
    }
    
    return matching_files;
}

// File validation
export fun is_valid_filename(filename: String) -> bool {
    // Check for invalid characters
    let invalid_chars: String[] = ["<", ">", ":", "\"", "|", "?", "*"];
    
    let i: int = 0;
    while (i < len(invalid_chars)) {
        if (filename.contains(invalid_chars[i])) {
            return false;
        }
        i = i + 1;
    }
    
    // Check for reserved names (Windows)
    let reserved_names: String[] = ["CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"];
    
    let upper_filename: String = filename.to_upper();
    i = 0;
    while (i < len(reserved_names)) {
        if (upper_filename == reserved_names[i]) {
            return false;
        }
        i = i + 1;
    }
    
    return true;
}

export fun sanitize_filename(filename: String) -> String {
    let invalid_chars: String[] = ["<", ">", ":", "\"", "|", "?", "*"];
    let replacement: String = "_";
    
    let result: String = filename;
    let i: int = 0;
    while (i < len(invalid_chars)) {
        result = result.replace(invalid_chars[i], replacement);
        i = i + 1;
    }
    
    return result;
}

// File comparison
export fun files_are_equal(path1: String, path2: String) -> bool {
    if (!file_exists(path1) || !file_exists(path2)) {
        return false;
    }
    
    let content1: String = read_file(path1);
    let content2: String = read_file(path2);
    
    return content1 == content2;
}

export fun get_file_hash(path: String) -> String {
    // Simple hash implementation
    let content: String = read_file(path);
    let hash: int = 0;
    
    let i: int = 0;
    while (i < len(content)) {
        hash = hash + content[i] as int;
        hash = hash * 31;
        hash = hash % 2147483647; // Prevent overflow
        i = i + 1;
    }
    
    return hash as String;
}

// Temporary files
export fun create_temp_file(content: String) -> String {
    let temp_name: String = "temp_" + current_time().replace(":", "") + ".tmp";
    write_file(temp_name, content);
    return temp_name;
}

export fun cleanup_temp_file(path: String) -> bool {
    if (path.starts_with("temp_") && path.ends_with(".tmp")) {
        return remove_file(path);
    }
    return false;
}
